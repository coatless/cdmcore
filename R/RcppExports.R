# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Constructs Unique Attribute Pattern Map
#'
#' Computes the powers of 2 from \eqn{0} up to \eqn{K - 1} for
#' \eqn{K}-dimensional attribute pattern.
#'
#' @param K  Number of Attributes.
#'
#' @return
#' A \code{vec} with length \eqn{K} detailing the power's of 2.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @seealso
#' [ecdmcore::attribute_inv_bijection()]
#'
#' @export
#' @examples
#' ## Construct an attribute bijection ----
#' biject = attribute_bijection(3)
attribute_bijection <- function(K) {
    .Call(`_edmcore_attribute_bijection`, K)
}

#' Perform an Inverse Bijection of an Integer to Attribute Pattern
#'
#' Convert an integer between \eqn{0} and \eqn{2^{K-1}} to
#' \eqn{K}-dimensional attribute pattern.
#'
#' @param CL An `integer` between \eqn{0} and \eqn{2^{K-1}}
#' @inheritParams attribute_bijection
#'
#' @return
#' A \eqn{K}-dimensional vector with an attribute pattern corresponding
#' to `CL`.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @seealso
#' [ecdmcore::attribute_bijection()]
#'
#' @export
#' @examples
#' ## Construct an attribute inversion bijection ----
#' inv_biject1 = attribute_inv_bijection(5, 1)
#' inv_biject2 = attribute_inv_bijection(5, 2)
attribute_inv_bijection <- function(K, CL) {
    .Call(`_edmcore_attribute_inv_bijection`, K, CL)
}

#' Simulate all the Latent Attribute Profile \eqn{\mathbf{\alpha}_c} in
#' Matrix form
#'
#' Generate the \eqn{\mathbf{\alpha}_c = (\alpha_{c1}, \ldots, \alpha_{cK})'}
#' attribute profile matrix for members of class \eqn{c} such that
#' \eqn{\alpha_{ck}} ' is 1 if members of class \eqn{c} possess skill \eqn{k}
#' and zero otherwise.
#'
#' @param K Number of Attributes
#'
#' @return
#' A \eqn{2^K} by \eqn{K} `matrix` of latent classes
#' corresponding to entry \eqn{c} of \eqn{pi} based upon
#' mastery and nonmastery of the \eqn{K} skills.
#'
#' @author
#' James Joseph Balamuta and Steven Andrew Culpepper
#'
#' @seealso
#' [simcdm::sim_subject_attributes()] and [simcdm::attribute_inv_bijection()]
#'
#' @export
#' @examples
#' ## Simulate Attribute Class Matrix ----
#'
#' # Define number of attributes
#' K = 3
#'
#' # Generate an Latent Attribute Profile (Alpha) Matrix
#' alphas = attribute_classes(K)
attribute_classes <- function(K) {
    .Call(`_edmcore_attribute_classes`, K)
}

#' Verify Q Matrix is Strictly Identifiable
#'
#' Performs a check to see if Q is strictly identified or not.
#'
#' @param Q The Q matrix to be checked with dimensions \eqn{K \times J}{K x J}.
#'
#' @return
#' A `bool` with value either: false or true
#'
#' @noRd
#' @keywords internal
is_strict_q_identified <- function(Q) {
    .Call(`_edmcore_is_strict_q_identified`, Q)
}

#' Permute indices
#'
#' Constructs and permutes indices within a vector
#'
#' @param nClass Number of classes given by \eqn{2^K}.
#' @param K      Number of Attributes
#' @param order  Degree of Order
#' @param vv     Bijection vector
#' @param perm   Permutations
#' @noRd
#'
#' @return
#' Permuted table at specified indices.
permuteAtableIndices <- function(nClass, K, order, vv, perm) {
    .Call(`_edmcore_permuteAtableIndices`, nClass, K, order, vv, perm)
}

