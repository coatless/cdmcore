# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Constructs Unique Attribute Pattern Map for Binary Data
#'
#' Computes the powers of 2 from \eqn{0} up to \eqn{K - 1} for
#' \eqn{K}-dimensional attribute pattern.
#'
#' @param K  Number of Attributes.
#'
#' @return
#' A \code{vec} with length \eqn{K} detailing the power's of 2.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @seealso
#' [attribute_inv_bijection()]
#'
#' @details
#'
#' The bijection vector generated is \eqn{\mathbf v = (2^{K-1},2^{K-2},\dots,1)^\top}.
#' With the bijection vector, there is a way to map the binary
#' latent class with \eqn{c=\mathbf\alpha_c^\top\mathbf v\in\{0, 1,\dots, 2^{K}-1\}}.
#' For example, for \eqn{K = 2}, \eqn{\mathbf v=(2, 1)^\top}
#' and the integer representations for attribute profiles
#' \eqn{\mathbf \alpha_0=(0,0)^\top},
#' \eqn{\mathbf \alpha_1=(0,1)^\top}, \eqn{\mathbf \alpha_2=(1, 0)^\top}, and
#' \eqn{\mathbf \alpha_3=(1,1)^\top} are \eqn{c} = 0, 1, 2, and 3,
#' respectively.
#'
#' @export
#' @examples
#' ## Construct an attribute bijection for binary data ----
#' bijection_k3 = attribute_bijection(3)
#'
#' bijection_k3
attribute_bijection <- function(K) {
    .Call(`_edmcore_attribute_bijection`, K)
}

#' Perform an Inverse Bijection of an Integer to Attribute Pattern for Binary Data
#'
#' Convert an integer between \eqn{0} and \eqn{2^{K-1}} to
#' \eqn{K}-dimensional attribute pattern.
#'
#' @param CL An `integer` between \eqn{0} and \eqn{2^{K-1}}
#' @inheritParams attribute_bijection
#'
#' @return
#' A \eqn{K}-dimensional vector with an attribute pattern corresponding
#' to `CL`.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @seealso
#' [attribute_bijection()]
#'
#' @export
#' @examples
#' ## Construct an attribute inversion bijection ----
#' inv_biject1 = attribute_inv_bijection(5, 1)
#' inv_biject1
#'
#' inv_biject2 = attribute_inv_bijection(5, 2)
#' inv_biject2
attribute_inv_bijection <- function(K, CL) {
    .Call(`_edmcore_attribute_inv_bijection`, K, CL)
}

#' Generate a vector to map polytomous vector to integers
#'
#' Creates a general bijection vector.
#'
#' @param K      Number of Attributes
#' @param M      Number of Responses
#'
#' @return
#' A `vec` with length \eqn{K} detailing the power's of \eqn{M}.
#'
#' @seealso
#' [attribute_inv_gen_bijection()] and [attribute_bijection()]
#'
#' @details
#' The bijection vector generated is
#' \eqn{\mathbf v = (M^{K-1},M^{K-2}, \dots, 1)^\top}.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @export
#' @examples
#' ## Construct an attribute bijection for M responses ----
#' biject_ternary = attribute_gen_bijection(5, 3)
#' biject_ternary
#'
#' ## Construct an attribute bijection for binary responses ----
#' biject_binary = attribute_gen_bijection(5, 2)
#' biject_binary
#'
#' ## Construct an attribute bijection for binary responses ----
#' biject_default = attribute_bijection(5)
#' biject_default
attribute_gen_bijection <- function(K, M) {
    .Call(`_edmcore_attribute_gen_bijection`, K, M)
}

#' Create the K inverse bijection of attribute vectors
#'
#' Converts the class into a bijection.
#'
#' @param K      Number of Attributes
#' @param M      Number of Options.
#' @param CL     Class Number from 0 to (2^K)-1.
#'
#' @return
#' Return a matrix containing the class table
#'
#' @seealso
#' [attribute_inv_bijection()], [attribute_gen_bijection()]
#'
#' @author
#' James Joseph Balamuta and Steven Andrew Culpepper
#'
#' @export
#' @examples
#' ## Construct an attribute bijection for M responses ----
#' inv_biject_ternary = attribute_inv_gen_bijection(5, 3, 2)
#' inv_biject_ternary
#'
#' ## Binary data
#' inv_biject_binary = attribute_inv_gen_bijection(5, 2, 4)
#' inv_biject_binary
#'
#' ## Default binary data
#' inv_biject_default = attribute_inv_bijection(5, 4)
#' inv_biject_default
attribute_inv_gen_bijection <- function(K, M, CL) {
    .Call(`_edmcore_attribute_inv_gen_bijection`, K, M, CL)
}

#' Simulate all the Latent Attribute Profile \eqn{\mathbf{\alpha}_c} in
#' Matrix form
#'
#' Generate the \eqn{\mathbf{\alpha}_c = (\alpha_{c1}, \ldots, \alpha_{cK})'}
#' attribute profile matrix for members of class \eqn{c} such that
#' \eqn{\alpha_{ck}} ' is 1 if members of class \eqn{c} possess skill \eqn{k}
#' and zero otherwise.
#'
#' @param K Number of Attributes
#'
#' @return
#' A \eqn{2^K} by \eqn{K} `matrix` of latent classes
#' corresponding to entry \eqn{c} of \eqn{pi} based upon
#' mastery and nonmastery of the \eqn{K} skills.
#'
#' @author
#' James Joseph Balamuta and Steven Andrew Culpepper
#'
#' @seealso
#' [simcdm::sim_subject_attributes()] and [attribute_inv_bijection()]
#'
#' @export
#' @examples
#' ## Simulate Attribute Class Matrix ----
#'
#' # Define number of attributes
#' K = 3
#'
#' # Generate an Latent Attribute Profile (Alpha) Matrix
#' alphas = attribute_classes(K)
attribute_classes <- function(K) {
    .Call(`_edmcore_attribute_classes`, K)
}

#' Generate tables to store the results during iterations
#'
#' Generate tables to store the results during iterations
#'
#' @param nClass   Number of Attribute Classes
#' @param M        Number of Responses
#' @param K        Number of Attributes
#' @param order    Order is 1, main-effects, 2 main-effects + interactions.
#'                 Highest level of interactions you want.
#'
#' @return
#'
#' Return a list containing the tables for different parameters
#'
#' @noRd
GenerateAtable <- function(nClass, K, M, order) {
    .Call(`_edmcore_GenerateAtable`, nClass, K, M, order)
}

n_choose_k <- function(n, k) {
    .Call(`_edmcore_n_choose_k`, n, k)
}

combination_matrix <- function(n, k) {
    .Call(`_edmcore_combination_matrix`, n, k)
}

combination_matrix_from_vector <- function(x, k) {
    .Call(`_edmcore_combination_matrix_from_vector`, x, k)
}

set_diff_cpp <- function(x, y) {
    .Call(`_edmcore_set_diff_cpp`, x, y)
}

is_q_generic_identified <- function(Q) {
    .Call(`_edmcore_is_q_generic_identified`, Q)
}

is_q_generic_complete <- function(Q) {
    .Call(`_edmcore_is_q_generic_complete`, Q)
}

binary_q_ideal <- function(k) {
    .Call(`_edmcore_binary_q_ideal`, k)
}

seq_linear_increase <- function(start, end) {
    .Call(`_edmcore_seq_linear_increase`, start, end)
}

seq_linear_decrease <- function(start, end) {
    .Call(`_edmcore_seq_linear_decrease`, start, end)
}

#' Verify Q Matrix is Strictly Identifiable
#'
#' Performs a check to see if Q is strictly identified or not.
#'
#' @param Q The Q matrix to be checked with dimensions \eqn{K \times J}{K x J}.
#'
#' @return
#' A `bool` with value either: false or true
#'
#' @noRd
#' @keywords internal
is_strict_q_identified <- function(Q) {
    .Call(`_edmcore_is_strict_q_identified`, Q)
}

#' Permute indices
#'
#' Constructs and permutes indices within a vector
#'
#' @param nClass Number of classes given by \eqn{2^K}.
#' @param K      Number of Attributes
#' @param order  Degree of Order
#' @param vv     Bijection vector
#' @param perm   Permutations
#' @noRd
#'
#' @return
#' Permuted table at specified indices.
permuteAtableIndices <- function(nClass, K, order, vv, perm) {
    .Call(`_edmcore_permuteAtableIndices`, nClass, K, order, vv, perm)
}

