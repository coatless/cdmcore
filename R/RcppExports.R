# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate a vector to map polytomous vector to integers
#'
#' Converts class into a bijection to integers
#'
#' @param M      Number of Responses
#' @param K      Number of Attributes
#'
#' @return
#'
#' Return a matrix containing the class table
#'
#' @export
NULL

#' Constructs Unique Attribute Pattern Map
#'
#' Computes the powers of 2 from \eqn{0} up to \eqn{K - 1} for
#' \eqn{K}-dimensional attribute pattern.
#'
#' @param K  Number of Attributes.
#'
#' @return
#' A \code{vec} with length \eqn{K} detailing the power's of 2.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @seealso
#' [attribute_inv_bijection()]
#'
#' @export
#' @examples
#' ## Construct an attribute bijection ----
#' biject = attribute_bijection(3)
attribute_bijection <- function(K) {
    .Call(`_edmcore_attribute_bijection`, K)
}

#' Perform an Inverse Bijection of an Integer to Attribute Pattern
#'
#' Convert an integer between \eqn{0} and \eqn{2^{K-1}} to
#' \eqn{K}-dimensional attribute pattern.
#'
#' @param CL An `integer` between \eqn{0} and \eqn{2^{K-1}}
#' @inheritParams attribute_bijection
#'
#' @return
#' A \eqn{K}-dimensional vector with an attribute pattern corresponding
#' to `CL`.
#'
#' @author
#' Steven Andrew Culpepper and James Joseph Balamuta
#'
#' @seealso
#' [attribute_bijection()]
#'
#' @export
#' @examples
#' ## Construct an attribute inversion bijection ----
#' inv_biject1 = attribute_inv_bijection(5, 1)
#' inv_biject2 = attribute_inv_bijection(5, 2)
attribute_inv_bijection <- function(K, CL) {
    .Call(`_edmcore_attribute_inv_bijection`, K, CL)
}

#' Create the K inverse bijection of attribute vectors
#'
#' Converts the class into a bijection.
#'
#' @param K      Number of Attributes
#' @param M      Number of Options.
#' @param CL     Class Number from 0 to (2^K)-1.
#'
#' @return
#'
#' Return a matrix containing the class table
#' @export
attribute_inv_gen_bijection <- function(K, M, CL) {
    .Call(`_edmcore_attribute_inv_gen_bijection`, K, M, CL)
}

#' Simulate all the Latent Attribute Profile \eqn{\mathbf{\alpha}_c} in
#' Matrix form
#'
#' Generate the \eqn{\mathbf{\alpha}_c = (\alpha_{c1}, \ldots, \alpha_{cK})'}
#' attribute profile matrix for members of class \eqn{c} such that
#' \eqn{\alpha_{ck}} ' is 1 if members of class \eqn{c} possess skill \eqn{k}
#' and zero otherwise.
#'
#' @param K Number of Attributes
#'
#' @return
#' A \eqn{2^K} by \eqn{K} `matrix` of latent classes
#' corresponding to entry \eqn{c} of \eqn{pi} based upon
#' mastery and nonmastery of the \eqn{K} skills.
#'
#' @author
#' James Joseph Balamuta and Steven Andrew Culpepper
#'
#' @seealso
#' [simcdm::sim_subject_attributes()] and [attribute_inv_bijection()]
#'
#' @export
#' @examples
#' ## Simulate Attribute Class Matrix ----
#'
#' # Define number of attributes
#' K = 3
#'
#' # Generate an Latent Attribute Profile (Alpha) Matrix
#' alphas = attribute_classes(K)
attribute_classes <- function(K) {
    .Call(`_edmcore_attribute_classes`, K)
}

#' Generate tables to store the results during iterations
#'
#' Generate tables to store the results during iterations
#'
#' @param nClass   Number of Attribute Classes
#' @param M        Number of Responses
#' @param K        Number of Attributes
#' @param order    Order is 1, main-effects, 2 main-effects + interactions.
#'               Highest level of interactions you want.
#'
#' @return
#'
#' Return a list containing the tables for different parameters
#'
#' @noRd
GenerateAtable <- function(nClass, K, M, order) {
    .Call(`_edmcore_GenerateAtable`, nClass, K, M, order)
}

n_choose_k <- function(n, k) {
    .Call(`_edmcore_n_choose_k`, n, k)
}

combination_matrix <- function(n, k) {
    .Call(`_edmcore_combination_matrix`, n, k)
}

combination_matrix_from_vector <- function(x, k) {
    .Call(`_edmcore_combination_matrix_from_vector`, x, k)
}

set_diff_cpp <- function(x, y) {
    .Call(`_edmcore_set_diff_cpp`, x, y)
}

is_q_generic_identified <- function(Q) {
    .Call(`_edmcore_is_q_generic_identified`, Q)
}

is_q_generic_complete <- function(Q) {
    .Call(`_edmcore_is_q_generic_complete`, Q)
}

binary_q_ideal <- function(k) {
    .Call(`_edmcore_binary_q_ideal`, k)
}

seq_linear_increase <- function(start, end) {
    .Call(`_edmcore_seq_linear_increase`, start, end)
}

seq_linear_decrease <- function(start, end) {
    .Call(`_edmcore_seq_linear_decrease`, start, end)
}

#' Verify Q Matrix is Strictly Identifiable
#'
#' Performs a check to see if Q is strictly identified or not.
#'
#' @param Q The Q matrix to be checked with dimensions \eqn{K \times J}{K x J}.
#'
#' @return
#' A `bool` with value either: false or true
#'
#' @noRd
#' @keywords internal
is_strict_q_identified <- function(Q) {
    .Call(`_edmcore_is_strict_q_identified`, Q)
}

#' Permute indices
#'
#' Constructs and permutes indices within a vector
#'
#' @param nClass Number of classes given by \eqn{2^K}.
#' @param K      Number of Attributes
#' @param order  Degree of Order
#' @param vv     Bijection vector
#' @param perm   Permutations
#' @noRd
#'
#' @return
#' Permuted table at specified indices.
permuteAtableIndices <- function(nClass, K, order, vv, perm) {
    .Call(`_edmcore_permuteAtableIndices`, nClass, K, order, vv, perm)
}

